{
    "contents" : "################ Helper Functions ################\n\n##################################################\n# prec: take arbitrary mat. M and route length k\n# postc: return adj. mat. of Hamiltonian paths of length k\n##################################################\n\nhamiltonian.len = function(M, k)\n{\n  if(k-1 == 0) { return(M) }\n  out <- M\n  for(i in 1:(k-1))\n  {\n    out <- out %*% M\n    diag(out) <- 0\n  }\n  return(out)\n}\n\n##################################################\n# desc: store all combos into a global var \n# purp: this will hopefully save time on optim\n##################################################\n\ncreate.combos <- function(n_v)\n{\n  out <- list()\n  for(k in 1:n_v)\n  {\n    out[[k]] <- t(combn(c(1:n_v), k))\n  }\n  return(out)\n}\n\n##################################################\n# prec: take interaction matrix A \n# postc: return interaction matrix I\n##################################################\n\nget.I.from.A = function(A)\n{\n  n_v <- nrow(A)\n  I <- diag(n_v+1)\n  \n  if(!exists(\"all.combos\") || length(all.combos) != n_v){\n    all.combos <<- create.combos(n_v)\n  }\n  for(k in 2:n_v)\n  {\n    combos <- all.combos[[k]]\n    deltas <- matrix(0, nrow(combos), n_v)\n    for(i in 1:nrow(combos))\n    {\n      combo <- combos[i,]\n      active_vars <- A[combo,combo]\n      routes <- hamiltonian.len(active_vars, k-1)\n      delta_row <- colSums(routes) \n      deltas[i,combo] <- delta_row\n    }\n    I <- rbind(I, cbind(matrix(0,nrow(deltas),1), deltas))\n  }\n  return(I)\n}\n\n##################################################\n# prec: take interaction matrix A and main effects\n# postc: return full beta matrix\n##################################################\n\nget.betas.from.network = function(A, ME) \n{\n  I <- get.I.from.A(A)\n  return(I %*% ME)\n}\n\n### get_interactions.R's fns\n\n##################################################\n# prec: take unrolled delta guess vector\n# postc: return squared error cost\n##################################################\n\n#TODO: poor coding; grabbing n_v and solve.betas from global scope\ncost_fn <- function(guess)\n{ \n  #shape into matrix and insert diagonal of 0's\n  A <- reshape.with.diag(guess, n_v)\n  betas.guess <- get.betas.from.network(A, solve.betas[1:(n_v+1),]) #nice code reusage!...\n  \n  return(sum((solve.betas - betas.guess)^2))\n}\n\nlibrary(\"minpack.lm\")\nlma_cost_fn <- function(guess)\n{ \n  #shape into matrix and insert diagonal of 0's\n  A <- reshape.with.diag(guess, n_v)\n  betas.guess <- get.betas.from.network(A, solve.betas[1:(n_v+1),]) #nice code reusage!...\n  \n  return(solve.betas - betas.guess)\n}\n\n##################################################\n# prec: take unrolled vector and side length\n# postc: return re-rolled matrix with a diagonal of 0's\n##################################################\n\nreshape.with.diag <- function(unr, s)\n{\n  ind <- s*0:(s-1)\n  val <- c(unr, rep(0, length(ind)))\n  id <- c(seq_along(unr), ind+0.5)\n  return(matrix(val[order(id)], s, s))\n}\n\n#############################################\n# TODO: calculate gradient as well...\n# Optimization methods\n#############################################\n\nbfgs = function(par = rep(.5, n_v^2-n_v))\n{\n  res <- optim(par, cost_fn, NULL, method = \"BFGS\")\n  return(res)\n}\n\nnelder.mead = function(par = (1:(n_v^2-n_v) * .1))\n{\n  res <- optim(par, cost_fn, method = \"Nelder-Mead\",\n               control = list(maxit = 20000))\n  return(res)\n}\n\nsim.anneal = function(par = rep(.5, n_v^2-n_v))\n{\n  res <- optim(par, cost_fn, method = \"SANN\",\n               control = list(maxit = 20000, temp = 20, parscale = rep(.5, n_v^2-n_v) ))\n  return(res)\n}\n\nlev.marq = function(par = rep(.5, n_v^2-n_v))\n{\n  nls.out <- nls.lm(par, lower=NULL, upper=NULL, lma_cost_fn, jac = NULL,\n                control = nls.lm.control())\n  return(nls.out)\n}\n\n##################################################\n# prec: take optimized delta values\n# postc: infer interaction values m\n##################################################\n\ninfer.m = function(D){\n  I = get.I.from.A(reshape.with.diag(D, n_v))\n  \n  #total variant activity\n  tot.activity = colSums(I)[-1] #column sums and remove first entry\n}",
    "created" : 1405696395484.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1673558195",
    "id" : "897050E6",
    "lastKnownWriteTime" : 1405696400,
    "path" : "~/JAX/simulation/epistasis-simulation/bin/lab/helper_fn.R",
    "project_path" : "bin/lab/helper_fn.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}