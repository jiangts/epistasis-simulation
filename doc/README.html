<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Extending R/cape: Multivariant Analysis</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}

pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Extending R/cape: Multivariant Analysis</h1>

<p>The purpose of this project is to test a new model to extend <code>R/cape</code> for the analysis of more than 2 variants simulataneously.</p>

<p>There are two parts to the code:</p>

<ul>
<li><code>create_data.R</code>, where we fabricate a dataset given an underlying variant-to-variant interaction network, and</li>
<li><code>get_interactions.R</code> where we use our new model on the fabricated marker and phenotype data to re-infer the underlying variant interactions.</li>
</ul>

<p>Using this methodology, we can implement the new model of analysis while testing its robustness as it responds to varying levels of noise that we can systematically introduce into the data.</p>

<hr/>

<h1>Running the code: an example</h1>

<h2>create_data.R</h2>

<p>Here is an example of the data generated by the script <code>create_data.R</code>. We set several parameters in the fabrication of this dataset, most notably</p>

<ul>
<li>1000 individuals,</li>
<li>3 phenotypes,</li>
<li>3 variants,</li>
<li>50% allelic frequency, and</li>
<li><strong>No noise</strong> &ndash; this will be updated shortly</li>
</ul>

<p>Then, using the underlying interaction matrix \(\boldsymbol{A}\), set to</p>

<!-- 

```r
library("MASS")
library("Matrix")
load("~/JAX/simulation/v1.3/bin/full_simulation.RData")
```
 -->

<pre><code class="r">print(dataset$A)
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  0.0  0.4  0.0
## [2,]  0.1  0.0  0.3
## [3,]  0.0  0.0  0.0
</code></pre>

<p>and the main effect matrix</p>

<pre><code class="r">print(params$ME_betas)
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  3.0  3.5  4.0
## [2,]  3.5  4.0  3.0
## [3,]  4.0  3.0  3.5
</code></pre>

<p>we created the \(\beta\) matrix.</p>

<pre><code class="r">print(dataset$betas)
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,] 1.00 1.00 1.00
## [2,] 3.00 3.50 4.00
## [3,] 3.50 4.00 3.00
## [4,] 4.00 3.00 3.50
## [5,] 1.70 1.95 1.60
## [6,] 0.00 0.00 0.00
## [7,] 1.20 0.90 1.05
## [8,] 0.48 0.36 0.42
</code></pre>

<p>Now, using the linear regression model
\[
Y \sim X \cdot \beta + \epsilon,
\]
where \(Y\) is the phenotype matrix (columns represent phenotypes, rows invididuals), \(X\) is the genotype matrix, and \(\beta\) is the weights matrix, we get the following fabricated data:</p>

<!-- colnames(X) <- c("x0", "x1", "x2", "x3", "x4", "x12", "x13", "x14", "x23", "x24", "x34", 
                 "x123", "x124", "x134", "x234", "x1234") -->

<pre><code class="r">colnames(X) &lt;- c(&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x12&quot;, &quot;x13&quot;, &quot;x23&quot;, &quot;x123&quot;)
head(X)
</code></pre>

<pre><code>##      x0 x1 x2 x3 x12 x13 x23 x123
## [1,]  1  0  1  1   0   0   1    0
## [2,]  1  0  1  1   0   0   1    0
## [3,]  1  1  1  2   1   2   2    2
## [4,]  1  1  2  1   2   1   2    2
## [5,]  1  1  0  1   0   1   0    0
## [6,]  1  1  0  0   0   0   0    0
</code></pre>

<pre><code class="r">head(Y)
</code></pre>

<pre><code>##       [,1]  [,2]  [,3]
## [1,]  9.70  8.90  8.55
## [2,]  9.70  8.90  8.55
## [3,] 20.56 18.97 19.54
## [4,] 21.76 21.92 20.64
## [5,]  8.00  7.50  8.50
## [6,]  4.00  4.50  5.00
</code></pre>

<hr/>

<h2>get_interactions.R</h2>

<!-- 
__TODO: there is currently a problem with delta matrix $\boldsymbol{I}$ generation involving routing and feedback.__ The part in `helper_fn.R` in the `get.I.from.A` method:
```
...
  active_vars <- A[combo,combo]
  routes <- active_vars %^% (k-1) #routes of length k-1
  diag(routes) <- 0
  delta_row <- colSums(routes) 
...
``` -->

<p>To infer the values of the interactions from the marker data \(X\) and phenotype data \(Y\), we first find the weights \(\beta\) of our linear regression model. Since</p>

<p>\[\beta \approx X^{-1} \cdot Y,\]</p>

<p>in <code>R</code> we do:</p>

<pre><code class="r">ginv(X) %*% Y
</code></pre>

<pre><code>##           [,1]       [,2]      [,3]
## [1,] 1.000e+00  1.000e+00 1.000e+00
## [2,] 3.000e+00  3.500e+00 4.000e+00
## [3,] 3.500e+00  4.000e+00 3.000e+00
## [4,] 4.000e+00  3.000e+00 3.500e+00
## [5,] 1.700e+00  1.950e+00 1.600e+00
## [6,] 7.772e-16 -1.665e-16 4.621e-15
## [7,] 1.200e+00  9.000e-01 1.050e+00
## [8,] 4.800e-01  3.600e-01 4.200e-01
</code></pre>

<p>Notice that these values are essentially equal to the original \(\beta\) values. That&#39;s because we didn&#39;t add any noise to the data yet.</p>

<p>Continuing, we want to find the interaction matrix \(\boldsymbol{A}\) filled with \(\delta\)&#39;s that best fits the following system by the least squares criterion.</p>

<p>\[\begin{cases} 
  \beta_{12}^1 = \beta_{1}^1\delta_{21} + \beta_{2}^1\delta_{12} \\ 
  \beta_{12}^2 = \beta_{1}^2\delta_{21} + \beta_{2}^2\delta_{12} \\ 
  \ldots \\ 
  \beta_{123}^2 = \beta_{1}^2(\delta_{21} + \delta_{31} + \delta_{23}\delta_{31} + \delta_{32}\delta_{21}) + \beta_{2}^2(\delta_{12} + \delta_{32} + \delta_{13}\delta_{32} + \delta_{31}\delta_{12}) \\ 
  \beta_{123}^3 = \beta_{1}^3(\delta_{21} + \delta_{31} + \delta_{23}\delta_{31} + \delta_{32}\delta_{21}) + \beta_{2}^3(\delta_{12} + \delta_{32} + \delta_{13}\delta_{32} + \delta_{31}\delta_{12})
\end{cases}\]
<strong>Note:</strong> Example system of equations above is for the 3 variant 3 phenotype case.</p>

<p>Enumerating all the cases, we see that we have 12 equations and 6 variables. (In general, we will have \(p (2^v - v - 1)\) equations and \(2{v \choose 2}\) variables.)</p>

<p>Now, our task is to find the best \(\delta\)&#39;s to fit the equations. We use a series of four optimization algorithms to look for the minima: </p>

<ul>
<li>BFGS, a gradient search method, </li>
<li>Levenberg-Marquardt, a hybrid between gradient descent and Newton&#39;s method, </li>
<li>Nelder-Mead, a simplex method, and </li>
<li>Simulated Annealing, an entropy-based random global search method.</li>
</ul>

<p>We show the results for each here:</p>

<pre><code>solve.bfgs &lt;- bfgs()
</code></pre>

<pre><code class="r">print(solve.bfgs)
</code></pre>

<pre><code>## $par
## [1]  1.000e-01  2.632e-10  4.000e-01  3.657e-10 -2.064e-10  3.000e-01
## 
## $value
## [1] 8.085e-19
## 
## $counts
## function gradient 
##       86       40 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<pre><code class="r">signif(reshape.with.diag(solve.bfgs$par, n_v), digits=4)
</code></pre>

<pre><code>##           [,1]      [,2]       [,3]
## [1,] 0.000e+00 4.000e-01 -2.064e-10
## [2,] 1.000e-01 0.000e+00  3.000e-01
## [3,] 2.632e-10 3.657e-10  0.000e+00
</code></pre>

<pre><code>solve.lev.marq &lt;- lev.marq()
</code></pre>

<pre><code class="r">print(solve.lev.marq)
</code></pre>

<pre><code>## Nonlinear regression via the Levenberg-Marquardt algorithm
## parameter estimates: 0.100000000789061, -1.28844058347826e-09, 0.399999999194725, -3.19963929952106e-09, 1.26249932914136e-09, 0.300000003569382 
## residual sum-of-squares: 2.78e-17
## reason terminated: Relative error between `par&#39; and the solution is at most `ptol&#39;.
</code></pre>

<pre><code class="r">signif(reshape.with.diag(solve.lev.marq$par, n_v), digits=4)
</code></pre>

<pre><code>##            [,1]     [,2]      [,3]
## [1,]  0.000e+00  4.0e-01 1.262e-09
## [2,]  1.000e-01  0.0e+00 3.000e-01
## [3,] -1.288e-09 -3.2e-09 0.000e+00
</code></pre>

<pre><code>solve.nelder.mead &lt;- nelder.mead()
</code></pre>

<pre><code class="r">print(solve.nelder.mead)
</code></pre>

<pre><code>## $par
## [1]  9.982e-02  8.360e-05  4.001e-01 -6.436e-05 -3.736e-05  3.000e-01
## 
## $value
## [1] 6.142e-07
## 
## $counts
## function gradient 
##     1457       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<pre><code class="r">signif(reshape.with.diag(solve.nelder.mead$par, n_v), digits=4)
</code></pre>

<pre><code>##           [,1]       [,2]       [,3]
## [1,] 0.0000000  4.001e-01 -3.736e-05
## [2,] 0.0998200  0.000e+00  3.000e-01
## [3,] 0.0000836 -6.436e-05  0.000e+00
</code></pre>

<pre><code>solve.sim.anneal &lt;- sim.anneal()
</code></pre>

<pre><code class="r">print(solve.sim.anneal)
</code></pre>

<pre><code>## $par
## [1]  0.17651  0.17997  0.27681  0.02929 -0.19097  0.27415
## 
## $value
## [1] 0.1771
## 
## $counts
## function gradient 
##    20000       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<pre><code class="r">signif(reshape.with.diag(solve.sim.anneal$par, n_v), digits=4)
</code></pre>

<pre><code>##        [,1]    [,2]    [,3]
## [1,] 0.0000 0.27680 -0.1910
## [2,] 0.1765 0.00000  0.2741
## [3,] 0.1800 0.02929  0.0000
</code></pre>

<p>We see that the results in the solution vector (called <code>par</code>, for the parameter vector) is quite similar for BFGS and Nelder Mead. This is reassuring as BFGS is a gradient method (and its performance generally depends on the initial guess), whereas Nelder-Mead is a global search method whose ability to find a minimum is less dependent on the intialization point. Thus, our method can show us with some confidence where the global minimum is.</p>

<p>Furthermore, we see that our method has done well in finding the global minimum in this case, as the output matrices are very close to the original seeded interaction matrix.</p>

</body>

</html>
