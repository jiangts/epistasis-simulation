<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Epistasis-simulation : creating simulated data to test statistical techniques to detect gene-gene interactions." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Epistasis-simulation</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jiangts/epistasis-simulation">View on GitHub</a>

          <h1 id="project_title">Epistasis-simulation</h1>
          <h2 id="project_tagline">creating simulated data to test statistical techniques to detect gene-gene interactions.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jiangts/epistasis-simulation/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jiangts/epistasis-simulation/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="extending-rcape-multivariant-analysis" class="anchor" href="#extending-rcape-multivariant-analysis"><span class="octicon octicon-link"></span></a>Extending R/cape: Multivariant Analysis</h1>

<p>The purpose of this project is to test a new model to extend <code>R/cape</code> for the analysis of more than 2 variants simulataneously.</p>

<p>There are two parts to the code:</p>

<ul>
<li>
<code>create_data.R</code>, where we fabricate a dataset given an underlying variant-to-variant interaction network, and</li>
<li>
<code>get_interactions.R</code> where we use our new model on the fabricated marker and phenotype data to re-infer the underlying variant interactions.</li>
</ul><p>Using this methodology, we can implement the new model of analysis while testing its robustness as it responds to varying levels of noise that we can systematically introduce into the data.</p>

<hr><h1>
<a name="running-the-code-an-example" class="anchor" href="#running-the-code-an-example"><span class="octicon octicon-link"></span></a>Running the code: an example</h1>

<h2>
<a name="create_datar" class="anchor" href="#create_datar"><span class="octicon octicon-link"></span></a>create_data.R</h2>

<p>Here is an example of the data generated by the script <code>create_data.R</code>. We set several parameters in the fabrication of this dataset, most notably</p>

<ul>
<li>1000 individuals,</li>
<li>3 phenotypes,</li>
<li>3 variants,</li>
<li>50% allelic frequency, and</li>
<li>
<strong>No noise</strong> -- this will be updated shortly</li>
</ul><p>Then, using the underlying interaction matrix $\boldsymbol{A}$, set to</p>



<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>A<span class="p">)</span>
</pre></div>

<pre><code>##      [,1] [,2] [,3]
## [1,]  0.0  0.4  0.0
## [2,]  0.1  0.0  0.3
## [3,]  0.0  0.0  0.0
</code></pre>

<p>and the main effect matrix</p>

<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>ME_betas<span class="p">)</span>
</pre></div>

<pre><code>##      [,1] [,2] [,3]
## [1,]  3.0  3.5  4.0
## [2,]  3.5  4.0  3.0
## [3,]  4.0  3.0  3.5
</code></pre>

<p>we created the $\beta$ matrix.</p>

<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>betas<span class="p">)</span>
</pre></div>

<pre><code>##      [,1] [,2] [,3]
## [1,] 1.00 1.00 1.00
## [2,] 3.00 3.50 4.00
## [3,] 3.50 4.00 3.00
## [4,] 4.00 3.00 3.50
## [5,] 1.70 1.95 1.60
## [6,] 0.00 0.00 0.00
## [7,] 1.20 0.90 1.05
## [8,] 0.48 0.36 0.42
</code></pre>

<p>Now, using the linear regression model
$$
Y \sim X \cdot \beta + \epsilon,
$$
where $Y$ is the phenotype matrix (columns represent phenotypes, rows invididuals), $X$ is the genotype matrix, and $\beta$ is the weights matrix, we get the following fabricated data:</p>

<div class="highlight highlight-r"><pre><span class="kp">colnames</span><span class="p">(</span>X<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">"x0"</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">,</span> <span class="s">"x2"</span><span class="p">,</span> <span class="s">"x3"</span><span class="p">,</span> <span class="s">"x12"</span><span class="p">,</span> <span class="s">"x13"</span><span class="p">,</span> <span class="s">"x23"</span><span class="p">,</span> <span class="s">"x123"</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>X<span class="p">)</span>
</pre></div>

<pre><code>##      x0 x1 x2 x3 x12 x13 x23 x123
## [1,]  1  2  2  2   4   4   4    8
## [2,]  1  2  1  0   2   0   0    0
## [3,]  1  1  1  1   1   1   1    1
## [4,]  1  0  1  2   0   0   2    0
## [5,]  1  2  2  0   4   0   0    0
## [6,]  1  0  1  1   0   0   1    0
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">head</span><span class="p">(</span>Y<span class="p">)</span>
</pre></div>

<pre><code>##       [,1]  [,2]  [,3]
## [1,] 37.44 36.28 35.96
## [2,] 13.90 15.90 15.20
## [3,] 14.88 14.71 14.57
## [4,] 14.90 12.80 13.10
## [5,] 20.80 23.80 21.40
## [6,]  9.70  8.90  8.55
</code></pre>

<hr><h2>
<a name="get_interactionsr" class="anchor" href="#get_interactionsr"><span class="octicon octicon-link"></span></a>get_interactions.R</h2>



<p>To infer the values of the interactions from the marker data $X$ and phenotype data $Y$, we first find the weights $\beta$ of our linear regression model. Since</p>

<p>$$\beta \approx X^{-1} \cdot Y,$$</p>

<p>in <code>R</code> we do:</p>

<div class="highlight highlight-r"><pre>ginv<span class="p">(</span>X<span class="p">)</span> <span class="o">%*%</span> Y
</pre></div>

<pre><code>##           [,1]      [,2]      [,3]
## [1,] 1.000e+00 1.000e+00 1.000e+00
## [2,] 3.000e+00 3.500e+00 4.000e+00
## [3,] 3.500e+00 4.000e+00 3.000e+00
## [4,] 4.000e+00 3.000e+00 3.500e+00
## [5,] 1.700e+00 1.950e+00 1.600e+00
## [6,] 3.905e-14 3.987e-14 4.059e-14
## [7,] 1.200e+00 9.000e-01 1.050e+00
## [8,] 4.800e-01 3.600e-01 4.200e-01
</code></pre>

<p>Notice that these values are essentially equal to the original $\beta$ values. That's because we didn't add any noise to the data yet.</p>

<p>Continuing, we want to find the interaction matrix $\boldsymbol{A}$ filled with $\delta$'s that best fits the following system by the least squares criterion.</p>

<p>$$\begin{cases} 
  \beta_{12}^1 = \beta_{1}^1\delta_{21} + \beta_{2}^1\delta_{12} \\ 
  \beta_{12}^2 = \beta_{1}^2\delta_{21} + \beta_{2}^2\delta_{12} \\ 
  \ldots \\ 
  \beta_{123}^2 = \beta_{1}^2(\delta_{21} + \delta_{31} + \delta_{23}\delta_{31} + \delta_{32}\delta_{21}) + \beta_{2}^2(\delta_{12} + \delta_{32} + \delta_{13}\delta_{32} + \delta_{31}\delta_{12}) \\ 
  \beta_{123}^3 = \beta_{1}^3(\delta_{21} + \delta_{31} + \delta_{23}\delta_{31} + \delta_{32}\delta_{21}) + \beta_{2}^3(\delta_{12} + \delta_{32} + \delta_{13}\delta_{32} + \delta_{31}\delta_{12}) 
\end{cases}$$</p>

<p>Enumerating all the cases, we see that we have 12 equations and 6 variables. (In general, we will have $p (2^v - v - 1)$ equations and ${v \choose 2}$ variables.)</p>

<p>Now, our task is to find the best $\delta$'s to fit the 12 equations. We use a series of three optimization algorithms to look for the minima: BFGS, a gradient search method, Nelder-Mead, a simplex method, and Simulated Annealing, an entropy-based random global search method.</p>

<p>We show the results for each here:</p>

<pre><code>solve.bfgs &lt;- bfgs()
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>solve.bfgs<span class="p">)</span>
</pre></div>

<pre><code>## $par
## [1]  1.000e-01  2.632e-10  4.000e-01  3.657e-10 -2.064e-10  3.000e-01
## 
## $value
## [1] 8.085e-19
## 
## $counts
## function gradient 
##       86       40 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">signif</span><span class="p">(</span>reshape.with.diag<span class="p">(</span>solve.bfgs<span class="o">$</span>par<span class="p">,</span> n_v<span class="p">),</span> digits<span class="o">=</span><span class="m">4</span><span class="p">)</span>
</pre></div>

<pre><code>##           [,1]      [,2]       [,3]
## [1,] 0.000e+00 4.000e-01 -2.064e-10
## [2,] 1.000e-01 0.000e+00  3.000e-01
## [3,] 2.632e-10 3.657e-10  0.000e+00
</code></pre>

<pre><code>solve.nelder.mead &lt;- nelder.mead()
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>solve.nelder.mead<span class="p">)</span>
</pre></div>

<pre><code>## $par
## [1]  9.982e-02  8.360e-05  4.001e-01 -6.436e-05 -3.736e-05  3.000e-01
## 
## $value
## [1] 6.142e-07
## 
## $counts
## function gradient 
##     1457       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">signif</span><span class="p">(</span>reshape.with.diag<span class="p">(</span>solve.nelder.mead<span class="o">$</span>par<span class="p">,</span> n_v<span class="p">),</span> digits<span class="o">=</span><span class="m">4</span><span class="p">)</span>
</pre></div>

<pre><code>##           [,1]       [,2]       [,3]
## [1,] 0.0000000  4.001e-01 -3.736e-05
## [2,] 0.0998200  0.000e+00  3.000e-01
## [3,] 0.0000836 -6.436e-05  0.000e+00
</code></pre>

<pre><code>solve.sim.anneal &lt;- sim.anneal()
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">print</span><span class="p">(</span>solve.sim.anneal<span class="p">)</span>
</pre></div>

<pre><code>## $par
## [1]  0.1881  0.2623  0.3234  0.1271 -0.2809  0.2055
## 
## $value
## [1] 0.2264
## 
## $counts
## function gradient 
##    20000       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
</code></pre>

<div class="highlight highlight-r"><pre><span class="kp">signif</span><span class="p">(</span>reshape.with.diag<span class="p">(</span>solve.sim.anneal<span class="o">$</span>par<span class="p">,</span> n_v<span class="p">),</span> digits<span class="o">=</span><span class="m">4</span><span class="p">)</span>
</pre></div>

<pre><code>##        [,1]   [,2]    [,3]
## [1,] 0.0000 0.3234 -0.2809
## [2,] 0.1881 0.0000  0.2055
## [3,] 0.2623 0.1271  0.0000
</code></pre>

<p>We see that the results in the solution vector (called <code>par</code>, for the parameter vector) is quite similar for BFGS and Nelder Mead. This is reassuring as BFGS is a gradient method (and its performance generally depends on the initial guess), whereas Nelder-Mead is a global search method whose ability to find a minimum is less dependent on the intialization point. Thus, our method can show us with some confidence where the global minimum is.</p>

<p>Furthermore, we see that our method has done well in finding the global minimum in this case, as the output matrices are very close to the original seeded interaction matrix.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Epistasis-simulation maintained by <a href="https://github.com/jiangts">jiangts</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
